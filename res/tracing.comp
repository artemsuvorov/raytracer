#version 460 core

layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D screen;

#define MAX_DISTANCE 1000.0
#define MAX_SIZE     16
#define MAX_BOUNCES  2

struct Ray
{
    vec3 origin, direction;
};

struct Sphere
{
    vec3 origin;
    float radius;
    vec3 albedo;
};

uniform vec3 u_CameraPosition;

layout (std140, binding = 1) uniform u_SphereBlock {
    Sphere spheres[MAX_SIZE];
};

struct Hit
{
    float dist;
    vec3 position, normal;
    vec3 material_albedo;
};

Hit closest(Ray ray, float dist, Sphere sphere)
{
    Hit hit;
    hit.dist = dist;
    hit.position = ray.origin + ray.direction * dist;
    hit.normal = normalize(hit.position - sphere.origin);
    hit.material_albedo = sphere.albedo;
    return hit;
}

float intersect_sphere(Ray ray, Sphere sphere)
{
    vec3 origin = ray.origin - sphere.origin;
    float radius = sphere.radius;
    
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(origin, ray.direction);
    float c = dot(origin, origin) - radius * radius;
    
    float discriminant = b * b - 4.0 * a * c;
    if (discriminant >= 0.0)    
        return (-b - sqrt(discriminant)) / (2.0 * a);

    return MAX_DISTANCE;
}

Hit trace_ray(Ray ray)
{
    Hit closest_hit;
    closest_hit.dist = MAX_DISTANCE;
    
    for (int i = 0; i < MAX_SIZE; i++)
    {
        float dist = intersect_sphere(ray, spheres[i]);
        if (dist > 0.0 && dist < closest_hit.dist)
            closest_hit = closest(ray, dist, spheres[i]);
    }
    
    return closest_hit;
}

vec4 per_pixel(vec2 uv)
{
    Ray ray;
    ray.origin = u_CameraPosition;
    ray.direction = normalize(vec3(uv, -1.0));
    
    vec3 color = vec3(0.0);
    float multiplier = 1.0;
    
    for (int i = 0; i < MAX_BOUNCES; i++)
    {
        Hit hit = trace_ray(ray);
        if (hit.dist >= MAX_DISTANCE)
        {
            color += vec3(0.0, 0.0, 0.0) * multiplier;
            break;
        }
        
        vec3 light_direction = normalize(vec3(-1.0, -1.0, -1.0));
        float light_intensity = max(0.0, dot(hit.normal, -light_direction));
        color += hit.material_albedo * light_intensity * multiplier;
        multiplier *= 0.7;
        
        ray.origin = hit.position + hit.normal * 0.0001;
        ray.direction = reflect(ray.direction, hit.normal);
    }
    
    return vec4(color, 1.0);
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(screen);
    vec2 uv = (coord - 0.5 * resolution) / resolution.y;
    vec4 pixel = per_pixel(uv);
    imageStore(screen, coord, pixel);
}